import json
import logging
import os.path as op
import random
import re

import pytest

from kmbio.PDB import (DEFAULT_ROUTES, MMCIF2Dict, MMCIFParser, PDBParser, ProcessRemark350,
                       allequal, get_mmcif_bioassembly_data, open_url, sort_structure)

random.seed(42)
logger = logging.getLogger(__name__)

URL = "ftp://ftp.wwpdb.org/pub/pdb/data/"

TEST_DATA = [
    # (pdb_id, bioassembly_id)
    ('1y0x', 2),
    ('1y0o', 1),
    ('1y0y', 1),
    ('1dvf', 1),
]

with open(op.join(op.splitext(__file__)[0], 'test_bioassembly.json'), 'rt') as ifh:
    # (remark_350_data, bioassembly_data_ref)
    PDB_BIOASSEMBLY_DATA = json.load(ifh)

with open(op.join(op.splitext(__file__)[0], 'pdb_ids.json'), 'rt') as ifh:
    PDB_IDS = json.load(ifh)

with open(op.join(op.splitext(__file__)[0], 'pdb_bioassembly_files.json'), 'rt') as ifh:
    PDB_BIOASSEMBLY_FILES = json.load(ifh)

with open(op.join(op.splitext(__file__)[0], 'mmcif_bioassembly_files.json'), 'rt') as ifh:
    MMCIF_BIOASSEMBLY_FILES = json.load(ifh)


@pytest.mark.parametrize("bioassembly_dict", PDB_BIOASSEMBLY_DATA)
def test_process_line_350_1(bioassembly_dict):
    """Make sure that ProcessRemark350 correctly parses bioassembly data in PDBs.

    Uses a reference dictionary for test cases.
    """
    parser = ProcessRemark350()
    bioassembly_data = parser.process_lines(bioassembly_dict['remark_350_data'])
    bioassembly_data = json.loads(json.dumps(bioassembly_data))
    assert bioassembly_data == bioassembly_dict['bioassembly_data']


@pytest.mark.parametrize("pdb_id, bioassembly_id", TEST_DATA)
def test_process_line_350_2(pdb_id, bioassembly_id):
    """Make sure that ProcessRemark350 correctly parses bioassembly data in PDBs.

    Only validates for the presence of the bioassembly id in bioassembly_data.
    """
    pdb_url = DEFAULT_ROUTES['rcsb://'](pdb_id, 'pdb')
    with open_url(pdb_url) as ifh:
        data = [l for l in ifh if l.startswith('REMARK 350')]
    pr350 = ProcessRemark350()
    bioassembly_data = pr350.process_lines(data)
    assert str(bioassembly_id) in bioassembly_data
    logger.debug(bioassembly_data)


@pytest.mark.parametrize("pdb_id", PDB_IDS)
def test_pdb_vs_mmcif_bioassembly_data(pdb_id):
    """Make sure that the bioassembly data is the same in PDB and MMCIF files."""
    pdb_url = DEFAULT_ROUTES['rcsb://'](pdb_id, 'pdb')
    logger.debug(pdb_url)

    mmcif_url = DEFAULT_ROUTES['rcsb://'](pdb_id, 'cif')
    logger.debug(mmcif_url)

    with open_url(pdb_url) as fh:
        parser = PDBParser()
        parser.get_structure(fh)
        pdb_bioassembly_data = parser.header['bioassembly_data']

    with open_url(mmcif_url) as fh:
        sdict = MMCIF2Dict(fh)
        mmcif_bioassembly_data = get_mmcif_bioassembly_data(sdict, use_auth_id=True)

    # # Sort chain ids in ascending order because PDB and mmCIF bioasseblies
    # # may have them in different order
    # for bid in pdb_bioassembly_data:
    #     for i in range(len(pdb_bioassembly_data[bid])):
    #         pdb_bioassembly_data[bid][i]['chain_ids'].sort()
    #
    # for bid in mmcif_bioassembly_data:
    #     for i in range(len(mmcif_bioassembly_data[bid])):
    #         mmcif_bioassembly_data[bid][i]['chain_ids'].sort()

    assert len(pdb_bioassembly_data) == len(mmcif_bioassembly_data)

    for pdb_bioassembly_id, mmcif_bioassembly_id in zip(pdb_bioassembly_data,
                                                        mmcif_bioassembly_data):
        # Make sure chains are the same
        assert (list(pdb_bioassembly_data[pdb_bioassembly_id].keys()) == list(
            mmcif_bioassembly_data[mmcif_bioassembly_id].keys()))
        for (pdb_chain, pdb_transformation), (mmcif_chain, mmcif_transformation) in zip(
                pdb_bioassembly_data[pdb_bioassembly_id].items(),
                mmcif_bioassembly_data[mmcif_bioassembly_id].items()):
            assert pdb_transformation == mmcif_transformation, (pdb_chain, mmcif_chain)

    # assert pdb_bioassembly_data == mmcif_bioassembly_data


@pytest.mark.parametrize('pdb_bioassembly_file', random.sample(PDB_BIOASSEMBLY_FILES, 1000))
def test_pdb_vs_pdb_ref(pdb_bioassembly_file):
    """Compare PDB bioassemblies generated by `bio.PDB` to those provided by wwPDB."""
    if pdb_bioassembly_file in [
            #
            '3lnj.pdb2.gz',  # H_SPW treated as individual atoms in the PDB
            '2xd8.pdb1.gz',  # Not sure what's going on with this one...
    ]:
        pytest.xfail("This structure is known to fail.")

    # Filenames are of the form: '{pdb_id}.pdb{bioassembly_id}.gz'
    pdb_id, bioassembly_id = re.findall('(.*)\.pdb([0-9]+)\.gz', pdb_bioassembly_file)[0]
    logger.debug("pdb_id, bioassembly_id: %s, %s", pdb_id, bioassembly_id)

    pdb_url = DEFAULT_ROUTES['rcsb://'](pdb_id, 'pdb')
    logger.debug(pdb_url)

    pdb_bioassembly_url = (
        URL + "biounit/PDB/divided/{0}/{1}".format(pdb_id[1:3], pdb_bioassembly_file))
    logger.info(pdb_bioassembly_url)

    with open_url(pdb_url) as fh:
        pdb_structure = PDBParser().get_structure(fh, bioassembly_id=bioassembly_id)

    with open_url(pdb_bioassembly_url) as fh:
        pdb_bioassembly_structure = PDBParser().get_structure(fh)

    # Chains might be in a different order, but that's ok...
    sort_structure(pdb_structure)
    sort_structure(pdb_bioassembly_structure)

    assert allequal(pdb_structure, pdb_bioassembly_structure, 1e-2)


@pytest.mark.parametrize('pdb_bioassembly_file', random.sample(PDB_BIOASSEMBLY_FILES, 1000))
def test_mmcif_vs_pdb_ref(pdb_bioassembly_file):
    """Compare PDB bioassemblies generated by `bio.PDB` to those provided by wwPDB."""
    if pdb_bioassembly_file in [
            #
            '3lnj.pdb2.gz',  # H_SPW treated as individual atoms in the PDB
            '2xd8.pdb1.gz',  # Not sure what's going on with this one...
    ]:
        pytest.xfail("This structure is known to fail.")

    # Filenames are of the form: '{pdb_id}.pdb{bioassembly_id}.gz'
    pdb_id, bioassembly_id = re.findall('(.*)\.pdb([0-9]+)\.gz', pdb_bioassembly_file)[0]
    logger.debug("pdb_id, bioassembly_id: %s, %s", pdb_id, bioassembly_id)

    pdb_url = DEFAULT_ROUTES['rcsb://'](pdb_id, 'cif')
    logger.debug(pdb_url)

    pdb_bioassembly_url = (
        URL + "biounit/PDB/divided/{0}/{1}".format(pdb_id[1:3], pdb_bioassembly_file))
    logger.info(pdb_bioassembly_url)

    with open_url(pdb_url) as fh:
        pdb_structure = MMCIFParser(use_auth_id=True).get_structure(
            fh, bioassembly_id=bioassembly_id)

    with open_url(pdb_bioassembly_url) as fh:
        pdb_bioassembly_structure = PDBParser().get_structure(fh)

    # Chains might be in a different order, but that's ok...
    sort_structure(pdb_structure)
    sort_structure(pdb_bioassembly_structure)

    assert allequal(pdb_structure, pdb_bioassembly_structure, 1e-2)


def _condence_models(structure):
    """Move chains to previous models while making sure there are no duplicate chains.

    Bad Examples
    ------------
    (4jz4, 3) : The PDB bioassembly has chain 'A' on model '0' and chain 'B' on model 1.
    (2axh, 4) : Instad of (model '0' -> chains ['A', 'B'], model '1' -> chains ['A', 'B']),
                you have (model '0' -> chains ['A'], model '1' -> chains ['A'],
                          model '2' -> chains ['B'], model '3' -> chains ['B']).
    """
    if len(structure) <= 1:
        return None
    have_moves = True
    while have_moves:
        have_moves = False
        models = list(reversed(structure.ix[1:]))
        for i, model in list(enumerate(models)):
            logger.debug("i, model.id: %s, %s", i, model.id)
            model_prev = structure.ix[len(structure) - i - 2]
            for chain in list(model.values()):
                if chain.id not in model_prev:
                    logger.debug("Moving chain %s from model %s to model %s", chain.id, model.id,
                                 model_prev.id)
                    model_prev[chain.id] = chain
                    del model[chain.id]
                    have_moves = True
            if len(model) == 0:
                del structure[model.id]


@pytest.mark.parametrize('mmcif_bioassembly_file', random.sample(MMCIF_BIOASSEMBLY_FILES, 100))
def test_mmcif_vs_mmcif_ref(mmcif_bioassembly_file):
    """Compare structures generated by `bio.PDB` and PyMOL from the same MMCIF file."""
    # Filenames are of the form: '{pdb_id}-assembly{bioassembly_id}.cif.gz'
    pdb_id, bioassembly_id = re.findall('(.*)-assembly([0-9]+)\.cif\.gz', mmcif_bioassembly_file)[0]
    logger.debug("pdb_id, bioassembly_id: %s, %s", pdb_id, bioassembly_id)

    mmcif_url = DEFAULT_ROUTES['rcsb://'](pdb_id, 'cif')
    logger.debug(mmcif_url)

    mmcif_bioassembly_url = (
        URL + "biounit/mmCIF/divided/{0}/{1}".format(pdb_id[1:3], mmcif_bioassembly_file))
    logger.info(mmcif_bioassembly_url)

    with open_url(mmcif_url) as fh:
        mmcif_structure = MMCIFParser().get_structure(fh, bioassembly_id=bioassembly_id)

    with open_url(mmcif_bioassembly_url) as fh:
        mmcif_bioassembly_structure = MMCIFParser().get_structure(fh)

    assert allequal(mmcif_structure, mmcif_bioassembly_structure)
